"use strict";var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__hasOwnProp=Object.prototype.hasOwnProperty,__export=(e,o)=>{for(var t in o)__defProp(e,t,{get:o[t],enumerable:!0})},__copyProps=(e,o,t,n)=>{if(o&&"object"===typeof o||"function"===typeof o)for(let r of __getOwnPropNames(o))__hasOwnProp.call(e,r)||r===t||__defProp(e,r,{get:()=>o[r],enumerable:!(n=__getOwnPropDesc(o,r))||n.enumerable});return e},__toCommonJS=e=>__copyProps(__defProp({},"__esModule",{value:!0}),e),src_exports={};__export(src_exports,{GEOPARQUET_METADATA_JSON_SCHEMA:()=>GEOPARQUET_METADATA_JSON_SCHEMA,binaryToGeojson:()=>binaryToGeojson,binaryToGeometry:()=>binaryToGeometry,convertWKBTableToGeoJSON:()=>convertWKBTableToGeoJSON,flatGeojsonToBinary:()=>flatGeojsonToBinary,geojsonToBinary:()=>geojsonToBinary,geojsonToFlatGeojson:()=>geojsonToFlatGeojson,getGeoMetadata:()=>getGeoMetadata,getGeometryColumnsFromSchema:()=>getGeometryColumnsFromSchema,setGeoMetadata:()=>setGeoMetadata,transformBinaryCoords:()=>transformBinaryCoords,transformGeoJsonCoords:()=>transformGeoJsonCoords,unpackGeoMetadata:()=>unpackGeoMetadata,unpackJSONStringMetadata:()=>unpackJSONStringMetadata}),module.exports=__toCommonJS(src_exports);var GEOPARQUET_METADATA_JSON_SCHEMA={$schema:"http://json-schema.org/draft-07/schema#",title:"GeoParquet",description:"Parquet metadata included in the geo field.",type:"object",required:["version","primary_column","columns"],properties:{version:{type:"string",const:"1.0.0-beta.1"},primary_column:{type:"string",minLength:1},columns:{type:"object",minProperties:1,patternProperties:{".+":{type:"object",required:["encoding","geometry_types"],properties:{encoding:{type:"string",const:"WKB"},geometry_types:{type:"array",uniqueItems:!0,items:{type:"string",pattern:"^(GeometryCollection|(Multi)?(Point|LineString|Polygon))( Z)?$"}},crs:{oneOf:[{$ref:"https://proj.org/schemas/v0.5/projjson.schema.json"},{type:"null"}]},edges:{type:"string",enum:["planar","spherical"]},orientation:{type:"string",const:"counterclockwise"},bbox:{type:"array",items:{type:"number"},oneOf:[{description:"2D bbox consisting of (xmin, ymin, xmax, ymax)",minItems:4,maxItems:4},{description:"3D bbox consisting of (xmin, ymin, zmin, xmax, ymax, zmax)",minItems:6,maxItems:6}]},epoch:{type:"number"}}}},additionalProperties:!1}}};function getGeoMetadata(e){const o=parseJSONStringMetadata(e,"geo");if(!o)return null;for(const t of Object.values(o.columns||{}))t.encoding&&(t.encoding=t.encoding.toLowerCase());return o}function setGeoMetadata(e,o){const t=JSON.stringify(o);e.metadata.geo=t}function unpackGeoMetadata(e){const o=getGeoMetadata(e);if(!o)return;const{version:t,primary_column:n,columns:r}=o;t&&(e.metadata["geo.version"]=t),n&&(e.metadata["geo.primary_column"]=n),e.metadata["geo.columns"]=Object.keys(r||{}).join("");for(const[i,s]of Object.entries(r||{})){const o=e.fields.find((e=>e.name===i));o&&(o.name===n&&setFieldMetadata(o,"geo.primary_field","true"),unpackGeoFieldMetadata(o,s))}}function unpackGeoFieldMetadata(e,o){for(const[t,n]of Object.entries(o||{}))switch(t){case"geometry_types":setFieldMetadata(e,`geo.${t}`,n.join(","));break;case"bbox":setFieldMetadata(e,`geo.crs.${t}`,JSON.stringify(n));break;case"crs":for(const[o,t]of Object.entries(n||{}))if("id"===o){setFieldMetadata(e,`geo.crs.${o}`,"object"===typeof t?`${null==t?void 0:t.authority}:${null==t?void 0:t.code}`:JSON.stringify(t))}else setFieldMetadata(e,`geo.crs.${o}`,"string"===typeof t?t:JSON.stringify(t));break;default:setFieldMetadata(e,`geo.${t}`,"string"===typeof n?n:JSON.stringify(n))}}function setFieldMetadata(e,o,t){e.metadata=e.metadata||{},e.metadata[o]=t}function parseJSONStringMetadata(e,o){const t=e.metadata[o];if(!t)return null;try{const e=JSON.parse(t);return e&&"object"===typeof e?e:null}catch{return null}}function unpackJSONStringMetadata(e,o){const t=parseJSONStringMetadata(e,o);for(const[n,r]of Object.entries(t||{}))e.metadata[`${o}.${n}`]="string"===typeof r?r:JSON.stringify(r)}var GEOARROW_ENCODINGS=["geoarrow.multipolygon","geoarrow.polygon","geoarrow.multilinestring","geoarrow.linestring","geoarrow.multipoint","geoarrow.point","geoarrow.wkb","geoarrow.wkt"],GEOARROW_COLUMN_METADATA_ENCODING="ARROW:extension:name",GEOARROW_COLUMN_METADATA_METADATA="ARROW:extension:metadata";function getGeometryColumnsFromSchema(e){const o={};for(const t of e.fields){const e=getGeometryMetadataForField(t);e&&(o[t.name]=e)}return o}function getGeometryMetadataForField(e){var o,t;let n=null,r=null==(o=e.metadata)?void 0:o[GEOARROW_COLUMN_METADATA_ENCODING];r&&(r=r.toLowerCase(),"wkb"===r&&(r="geoarrow.wkb"),"wkt"===r&&(r="geoarrow.wkt"),GEOARROW_ENCODINGS.includes(r)?(n=n||{},n.encoding=r):console.warn(`Invalid GeoArrow encoding: ${r}`));const i=null==(t=e.metadata)?void 0:t[GEOARROW_COLUMN_METADATA_METADATA];if(i)try{n=JSON.parse(i)}catch(s){console.warn("Failed to parse GeoArrow metadata",s)}return n||null}var import_schema=require("@loaders.gl/schema");function convertWKBTableToGeoJSON(e,o,t){const n=getGeoMetadata(o),r=null==n?void 0:n.primary_column;if(!r)throw new Error("no geometry column");const i=n.columns[r],s=[],a=(0,import_schema.getTableLength)(e);for(let l=0;l<a;l++){const o=(0,import_schema.getTableRowAsObject)(e,l),n=parseGeometry(o[r],i,t);delete o[r];const a={type:"Feature",geometry:n,properties:o};s.push(a)}return{shape:"geojson-table",schema:o,type:"FeatureCollection",features:s}}function parseGeometry(e,o,t){var n,r;if("wkt"===o.encoding){const o=t.find((e=>"wkt"===e.id));return(null==(n=null==o?void 0:o.parseTextSync)?void 0:n.call(o,e))||null}{const o=t.find((e=>"wkb"===e.id)),n=ArrayBuffer.isView(e)?e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength):e;return null==(r=null==o?void 0:o.parseSync)?void 0:r.call(o,n,{wkb:{shape:"geojson-geometry"}})}}var import_polygon=require("@math.gl/polygon");function flatGeojsonToBinary(e,o,t){const n=extractNumericPropTypes(e),r=Object.keys(n).filter((e=>n[e]!==Array));return fillArrays(e,{propArrayTypes:n,...o},{numericPropKeys:t&&t.numericPropKeys||r,PositionDataType:t?t.PositionDataType:Float32Array,triangulate:!t||t.triangulate})}function extractNumericPropTypes(e){const o={};for(const t of e)if(t.properties)for(const e in t.properties){const n=t.properties[e];o[e]=deduceArrayType(n,o[e])}return o}function fillArrays(e,o,t){const{pointPositionsCount:n,pointFeaturesCount:r,linePositionsCount:i,linePathsCount:s,lineFeaturesCount:a,polygonPositionsCount:l,polygonObjectsCount:u,polygonRingsCount:c,polygonFeaturesCount:p,propArrayTypes:g,coordLength:d}=o,{numericPropKeys:y=[],PositionDataType:f=Float32Array,triangulate:m=!0}=t,P=e[0]&&"id"in e[0],h=e.length>65535?Uint32Array:Uint16Array,b={type:"Point",positions:new f(n*d),globalFeatureIds:new h(n),featureIds:r>65535?new Uint32Array(n):new Uint16Array(n),numericProps:{},properties:[],fields:[]},w={type:"LineString",pathIndices:i>65535?new Uint32Array(s+1):new Uint16Array(s+1),positions:new f(i*d),globalFeatureIds:new h(i),featureIds:a>65535?new Uint32Array(i):new Uint16Array(i),numericProps:{},properties:[],fields:[]},A={type:"Polygon",polygonIndices:l>65535?new Uint32Array(u+1):new Uint16Array(u+1),primitivePolygonIndices:l>65535?new Uint32Array(c+1):new Uint16Array(c+1),positions:new f(l*d),globalFeatureIds:new h(l),featureIds:p>65535?new Uint32Array(l):new Uint16Array(l),numericProps:{},properties:[],fields:[]};m&&(A.triangles=[]);for(const F of[b,w,A])for(const e of y){const o=g[e];F.numericProps[e]=new o(F.positions.length/d)}w.pathIndices[s]=i,A.polygonIndices[u]=l,A.primitivePolygonIndices[c]=l;const v={pointPosition:0,pointFeature:0,linePosition:0,linePath:0,lineFeature:0,polygonPosition:0,polygonObject:0,polygonRing:0,polygonFeature:0,feature:0};for(const F of e){const e=F.geometry,o=F.properties||{};switch(e.type){case"Point":handlePoint(e,b,v,d,o),b.properties.push(keepStringProperties(o,y)),P&&b.fields.push({id:F.id}),v.pointFeature++;break;case"LineString":handleLineString(e,w,v,d,o),w.properties.push(keepStringProperties(o,y)),P&&w.fields.push({id:F.id}),v.lineFeature++;break;case"Polygon":handlePolygon(e,A,v,d,o),A.properties.push(keepStringProperties(o,y)),P&&A.fields.push({id:F.id}),v.polygonFeature++;break;default:throw new Error("Invalid geometry type")}v.feature++}return makeAccessorObjects(b,w,A,d)}function handlePoint(e,o,t,n,r){o.positions.set(e.data,t.pointPosition*n);const i=e.data.length/n;fillNumericProperties(o,r,t.pointPosition,i),o.globalFeatureIds.fill(t.feature,t.pointPosition,t.pointPosition+i),o.featureIds.fill(t.pointFeature,t.pointPosition,t.pointPosition+i),t.pointPosition+=i}function handleLineString(e,o,t,n,r){o.positions.set(e.data,t.linePosition*n);const i=e.data.length/n;fillNumericProperties(o,r,t.linePosition,i),o.globalFeatureIds.fill(t.feature,t.linePosition,t.linePosition+i),o.featureIds.fill(t.lineFeature,t.linePosition,t.linePosition+i);for(let s=0,a=e.indices.length;s<a;++s){const r=e.indices[s],i=s===a-1?e.data.length:e.indices[s+1];o.pathIndices[t.linePath++]=t.linePosition,t.linePosition+=(i-r)/n}}function handlePolygon(e,o,t,n,r){o.positions.set(e.data,t.polygonPosition*n);const i=e.data.length/n;fillNumericProperties(o,r,t.polygonPosition,i),o.globalFeatureIds.fill(t.feature,t.polygonPosition,t.polygonPosition+i),o.featureIds.fill(t.polygonFeature,t.polygonPosition,t.polygonPosition+i);for(let s=0,a=e.indices.length;s<a;++s){const r=t.polygonPosition;o.polygonIndices[t.polygonObject++]=r;const i=e.areas[s],a=e.indices[s],l=e.indices[s+1];for(let s=0,u=a.length;s<u;++s){const r=a[s],i=s===u-1?void 0===l?e.data.length:l[0]:a[s+1];o.primitivePolygonIndices[t.polygonRing++]=t.polygonPosition,t.polygonPosition+=(i-r)/n}triangulatePolygon(o,i,a,{startPosition:r,endPosition:t.polygonPosition,coordLength:n})}}function triangulatePolygon(e,o,t,{startPosition:n,endPosition:r,coordLength:i}){if(!e.triangles)return;const s=n*i,a=r*i,l=e.positions.subarray(s,a),u=t[0],c=t.slice(1).map((e=>(e-u)/i)),p=(0,import_polygon.earcut)(l,c,i,o);for(let g=0,d=p.length;g<d;++g)e.triangles.push(n+p[g])}function wrapProps(e,o){const t={};for(const n in e)t[n]={value:e[n],size:o};return t}function makeAccessorObjects(e,o,t,n){const r={shape:"binary-feature-collection",points:{...e,positions:{value:e.positions,size:n},globalFeatureIds:{value:e.globalFeatureIds,size:1},featureIds:{value:e.featureIds,size:1},numericProps:wrapProps(e.numericProps,1)},lines:{...o,positions:{value:o.positions,size:n},pathIndices:{value:o.pathIndices,size:1},globalFeatureIds:{value:o.globalFeatureIds,size:1},featureIds:{value:o.featureIds,size:1},numericProps:wrapProps(o.numericProps,1)},polygons:{...t,positions:{value:t.positions,size:n},polygonIndices:{value:t.polygonIndices,size:1},primitivePolygonIndices:{value:t.primitivePolygonIndices,size:1},globalFeatureIds:{value:t.globalFeatureIds,size:1},featureIds:{value:t.featureIds,size:1},numericProps:wrapProps(t.numericProps,1)}};return r.polygons&&t.triangles&&(r.polygons.triangles={value:new Uint32Array(t.triangles),size:1}),r}function fillNumericProperties(e,o,t,n){for(const r in e.numericProps)if(r in o){const i=o[r];e.numericProps[r].fill(i,t,t+n)}}function keepStringProperties(e,o){const t={};for(const n in e)o.includes(n)||(t[n]=e[n]);return t}function deduceArrayType(e,o){return o!==Array&&Number.isFinite(e)?o===Float64Array||Math.fround(e)!==e?Float64Array:Float32Array:Array}function extractGeometryInfo(e){let o=0,t=0,n=0,r=0,i=0,s=0,a=0,l=0,u=0;const c=new Set;for(const p of e){const e=p.geometry;switch(e.type){case"Point":t++,o++,c.add(e.coordinates.length);break;case"MultiPoint":t++,o+=e.coordinates.length;for(const o of e.coordinates)c.add(o.length);break;case"LineString":i++,n+=e.coordinates.length,r++;for(const o of e.coordinates)c.add(o.length);break;case"MultiLineString":i++;for(const o of e.coordinates){n+=o.length,r++;for(const e of o)c.add(e.length)}break;case"Polygon":u++,a++,l+=e.coordinates.length;const p=e.coordinates.flat();s+=p.length;for(const e of p)c.add(e.length);break;case"MultiPolygon":u++;for(const o of e.coordinates){a++,l+=o.length;const e=o.flat();s+=e.length;for(const o of e)c.add(o.length)}break;default:throw new Error(`Unsupported geometry type: ${e.type}`)}}return{coordLength:c.size>0?Math.max(...c):2,pointPositionsCount:o,pointFeaturesCount:t,linePositionsCount:n,linePathsCount:r,lineFeaturesCount:i,polygonPositionsCount:s,polygonObjectsCount:a,polygonRingsCount:l,polygonFeaturesCount:u}}var import_polygon2=require("@math.gl/polygon");function geojsonToFlatGeojson(e,o={coordLength:2,fixRingWinding:!0}){return e.map((e=>flattenFeature(e,o)))}function flattenPoint(e,o,t,n){t.push(o.length),o.push(...e);for(let r=e.length;r<n.coordLength;r++)o.push(0)}function flattenLineString(e,o,t,n){t.push(o.length);for(const r of e){o.push(...r);for(let e=r.length;e<n.coordLength;e++)o.push(0)}}function flattenPolygon(e,o,t,n,r){let i=0;const s=[],a=[];for(const l of e){const e=l.map((e=>e.slice(0,2)));let t=(0,import_polygon2.getPolygonSignedArea)(e.flat());const n=t<0;r.fixRingWinding&&(0===i&&!n||i>0&&n)&&(l.reverse(),t=-t),s.push(t),flattenLineString(l,o,a,r),i++}i>0&&(n.push(s),t.push(a))}function flattenFeature(e,o){const{geometry:t}=e;if("GeometryCollection"===t.type)throw new Error("GeometryCollection type not supported");const n=[],r=[];let i,s;switch(t.type){case"Point":s="Point",flattenPoint(t.coordinates,n,r,o);break;case"MultiPoint":s="Point",t.coordinates.map((e=>flattenPoint(e,n,r,o)));break;case"LineString":s="LineString",flattenLineString(t.coordinates,n,r,o);break;case"MultiLineString":s="LineString",t.coordinates.map((e=>flattenLineString(e,n,r,o)));break;case"Polygon":s="Polygon",i=[],flattenPolygon(t.coordinates,n,r,i,o);break;case"MultiPolygon":s="Polygon",i=[],t.coordinates.map((e=>flattenPolygon(e,n,r,i,o)));break;default:throw new Error(`Unknown type: ${s}`)}return{...e,geometry:{type:s,indices:r,data:n,areas:i}}}function geojsonToBinary(e,o={fixRingWinding:!0,triangulate:!0}){const t=extractGeometryInfo(e),n=t.coordLength,{fixRingWinding:r}=o;return flatGeojsonToBinary(geojsonToFlatGeojson(e,{coordLength:n,fixRingWinding:r}),t,{numericPropKeys:o.numericPropKeys,PositionDataType:o.PositionDataType||Float32Array,triangulate:o.triangulate})}function binaryToGeojson(e,o){const t=null==o?void 0:o.globalFeatureId;return void 0!==t?getSingleFeature(e,t):parseFeatures(e,null==o?void 0:o.type)}function getSingleFeature(e,o){const t=normalizeInput(e);for(const n of t){let e=0,t=n.featureIds.value[0];for(let r=0;r<n.featureIds.value.length;r++){const i=n.featureIds.value[r];if(i!==t){if(o===n.globalFeatureIds.value[e])return parseFeature(n,e,r);e=r,t=i}}if(o===n.globalFeatureIds.value[e])return parseFeature(n,e,n.featureIds.value.length)}throw new Error(`featureId:${o} not found`)}function parseFeatures(e,o){return parseFeatureCollection(normalizeInput(e,o))}function binaryToGeometry(e,o,t){switch(e.type){case"Point":return pointToGeoJson(e,o,t);case"LineString":return lineStringToGeoJson(e,o,t);case"Polygon":return polygonToGeoJson(e,o,t);default:throw new Error(`Unsupported geometry type: ${null==e?void 0:e.type}`)}}function normalizeInput(e,o){const t=[];return e.points&&(e.points.type="Point",t.push(e.points)),e.lines&&(e.lines.type="LineString",t.push(e.lines)),e.polygons&&(e.polygons.type="Polygon",t.push(e.polygons)),t}function parseFeatureCollection(e){const o=[];for(const t of e){if(0===t.featureIds.value.length)continue;let e=0,n=t.featureIds.value[0];for(let r=0;r<t.featureIds.value.length;r++){const i=t.featureIds.value[r];i!==n&&(o.push(parseFeature(t,e,r)),e=r,n=i)}o.push(parseFeature(t,e,t.featureIds.value.length))}return o}function parseFeature(e,o,t){return{type:"Feature",geometry:binaryToGeometry(e,o,t),properties:parseProperties(e,o,t),...parseFields(e,o,t)}}function parseFields(e,o=0,t){return e.fields&&e.fields[e.featureIds.value[o]]}function parseProperties(e,o=0,t){const n=Object.assign({},e.properties[e.featureIds.value[o]]);for(const r in e.numericProps)n[r]=e.numericProps[r].value[o];return n}function polygonToGeoJson(e,o=-1/0,t=1/0){const{positions:n}=e,r=e.polygonIndices.value.filter((e=>e>=o&&e<=t)),i=e.primitivePolygonIndices.value.filter((e=>e>=o&&e<=t));if(!(r.length>2)){const e=[];for(let o=0;o<i.length-1;o++){const t=ringToGeoJson(n,i[o],i[o+1]);e.push(t)}return{type:"Polygon",coordinates:e}}const s=[];for(let a=0;a<r.length-1;a++){const o=polygonToGeoJson(e,r[a],r[a+1]).coordinates;s.push(o)}return{type:"MultiPolygon",coordinates:s}}function lineStringToGeoJson(e,o=-1/0,t=1/0){const{positions:n}=e,r=e.pathIndices.value.filter((e=>e>=o&&e<=t));if(!(r.length>2)){return{type:"LineString",coordinates:ringToGeoJson(n,r[0],r[1])}}const i=[];for(let s=0;s<r.length-1;s++){const e=ringToGeoJson(n,r[s],r[s+1]);i.push(e)}return{type:"MultiLineString",coordinates:i}}function pointToGeoJson(e,o,t){const{positions:n}=e,r=ringToGeoJson(n,o,t);return r.length>1?{type:"MultiPoint",coordinates:r}:{type:"Point",coordinates:r[0]}}function ringToGeoJson(e,o,t){o=o||0,t=t||e.value.length/e.size;const n=[];for(let r=o;r<t;r++){const o=Array();for(let t=r*e.size;t<(r+1)*e.size;t++)o.push(Number(e.value[t]));n.push(o)}return n}function transformBinaryCoords(e,o){return e.points&&transformBinaryGeometryPositions(e.points,o),e.lines&&transformBinaryGeometryPositions(e.lines,o),e.polygons&&transformBinaryGeometryPositions(e.polygons,o),e}function transformBinaryGeometryPositions(e,o){const{positions:t}=e;for(let n=0;n<t.value.length;n+=t.size){const e=o(Array.from(t.value.subarray(n,n+t.size)));t.value.set(e,n)}}function transformGeoJsonCoords(e,o){for(const t of e)t.geometry.coordinates=coordMap(t.geometry.coordinates,o);return e}function coordMap(e,o){return isCoord(e)?o(e):e.map((e=>coordMap(e,o)))}function isCoord(e){return Array.isArray(e)&&Number.isFinite(e[0])&&Number.isFinite(e[1])}