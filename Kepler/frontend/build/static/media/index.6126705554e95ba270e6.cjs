"use strict";var __create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__export=(r,e)=>{for(var o in e)__defProp(r,o,{get:e[o],enumerable:!0})},__copyProps=(r,e,o,t)=>{if(e&&"object"===typeof e||"function"===typeof e)for(let a of __getOwnPropNames(e))__hasOwnProp.call(r,a)||a===o||__defProp(r,a,{get:()=>e[a],enumerable:!(t=__getOwnPropDesc(e,a))||t.enumerable});return r},__toESM=(r,e,o)=>(o=null!=r?__create(__getProtoOf(r)):{},__copyProps(!e&&r&&r.__esModule?o:__defProp(o,"default",{value:r,enumerable:!0}),r)),__toCommonJS=r=>__copyProps(__defProp({},"__esModule",{value:!0}),r),src_exports={};__export(src_exports,{ArrowLoader:()=>ArrowLoader,ArrowWorkerLoader:()=>ArrowWorkerLoader,ArrowWriter:()=>ArrowWriter,GeoArrowLoader:()=>GeoArrowLoader,GeoArrowWorkerLoader:()=>GeoArrowWorkerLoader,TriangulationWorker:()=>TriangulationWorker,VECTOR_TYPES:()=>VECTOR_TYPES,convertArrowToGeoJSONTable:()=>convertArrowToGeoJSONTable,deserializeArrowField:()=>deserializeArrowField,deserializeArrowMetadata:()=>deserializeArrowMetadata,deserializeArrowSchema:()=>deserializeArrowSchema,deserializeArrowType:()=>deserializeArrowType,getArrowType:()=>getArrowType,getBinaryGeometriesFromArrow:()=>getBinaryGeometriesFromArrow,getBinaryGeometryTemplate:()=>getBinaryGeometryTemplate,getMeanCentersFromBinaryGeometries:()=>getMeanCentersFromBinaryGeometries,getTriangleIndices:()=>getTriangleIndices,hardClone:()=>hardClone,parseGeoArrowOnWorker:()=>parseGeoArrowOnWorker,parseGeometryFromArrow:()=>parseGeometryFromArrow2,serializeArrowField:()=>serializeArrowField,serializeArrowMetadata:()=>serializeArrowMetadata,serializeArrowSchema:()=>serializeArrowSchema,serializeArrowType:()=>serializeArrowType,triangulateOnWorker:()=>triangulateOnWorker,updateBoundsFromGeoArrowSamples:()=>updateBoundsFromGeoArrowSamples}),module.exports=__toCommonJS(src_exports);var import_schema3=require("@loaders.gl/schema"),import_schema=require("@loaders.gl/schema"),arrow=__toESM(require("apache-arrow"),1),ArrowTableBatchAggregator=class extends import_schema.ColumnarTableBatchAggregator{constructor(r,e){super(r,e),this.arrowSchema=null}getBatch(){const r=super.getBatch();if(r){this.arrowSchema=this.arrowSchema||getArrowSchema(r.schema);const e=getArrowVectors(this.arrowSchema,r.data),o=new arrow.RecordBatch(this.arrowSchema,arrow.makeData({type:new arrow.Struct(this.arrowSchema.fields),children:e.map((({data:r})=>r[0]))}));return{shape:"arrow-table",batchType:"data",data:new arrow.Table([o]),length:r.length}}return null}};function getArrowSchema(r){const e=[];for(const o in r){const t=r[o];if(t.type===Float32Array){const r=new Map,o=new arrow.Field(t.name,new arrow.Float32,t.nullable,r);e.push(o)}}if(0===e.length)throw new Error("No arrow convertible fields");return new arrow.Schema(e)}function getArrowVectors(r,e){const o=[];for(const t of r.fields){const r=e[t.name];if(r instanceof Float32Array){const e=arrow.makeVector(r);o.push(e)}}if(r.fields.length!==o.length)throw new Error("Some columns not arrow convertible");return o}var arrow2=__toESM(require("apache-arrow"),1);function getArrowType(r){switch(r.constructor){case Int8Array:return new arrow2.Int8;case Uint8Array:return new arrow2.Uint8;case Int16Array:return new arrow2.Int16;case Uint16Array:return new arrow2.Uint16;case Int32Array:return new arrow2.Int32;case Uint32Array:return new arrow2.Uint32;case Float32Array:return new arrow2.Float32;case Float64Array:return new arrow2.Float64;default:throw new Error("array type not supported")}}var VECTOR_TYPES=(r=>(r[r.FLOAT=0]="FLOAT",r[r.DATE=1]="DATE",r))(VECTOR_TYPES||{}),import_schema2=require("@loaders.gl/schema"),arrow4=__toESM(require("apache-arrow"),1);function convertArrowToColumnarTable(r){const e=r.data,o={};for(const t of e.schema.fields){const r=e.getChild(t.name),a=null==r?void 0:r.toArray();o[t.name]=a}return{shape:"columnar-table",schema:r.schema,data:o}}var arrow3=__toESM(require("apache-arrow"),1);function serializeArrowSchema(r){return{fields:r.fields.map((r=>serializeArrowField(r))),metadata:serializeArrowMetadata(r.metadata)}}function deserializeArrowSchema(r){return new arrow3.Schema(r.fields.map((r=>deserializeArrowField(r))),deserializeArrowMetadata(r.metadata))}function serializeArrowMetadata(r){return Object.fromEntries(r)}function deserializeArrowMetadata(r){return r?new Map(Object.entries(r)):new Map}function serializeArrowField(r){return{name:r.name,type:serializeArrowType(r.type),nullable:r.nullable,metadata:serializeArrowMetadata(r.metadata)}}function deserializeArrowField(r){return new arrow3.Field(r.name,deserializeArrowType(r.type),r.nullable,deserializeArrowMetadata(r.metadata))}function serializeArrowType(r){switch(r.constructor){case arrow3.Null:return"null";case arrow3.Binary:return"binary";case arrow3.Bool:return"bool";case arrow3.Int:const e=r;return`${e.isSigned?"u":""}int${e.bitWidth}`;case arrow3.Int8:return"int8";case arrow3.Int16:return"int16";case arrow3.Int32:return"int32";case arrow3.Int64:return"int64";case arrow3.Uint8:return"uint8";case arrow3.Uint16:return"uint16";case arrow3.Uint32:return"uint32";case arrow3.Uint64:return"uint64";case arrow3.Float:switch(r.precision){case arrow3.Precision.HALF:return"float16";case arrow3.Precision.SINGLE:return"float32";case arrow3.Precision.DOUBLE:return"float64";default:return"float16"}case arrow3.Float16:return"float16";case arrow3.Float32:return"float32";case arrow3.Float64:return"float64";case arrow3.Utf8:return"utf8";case arrow3.Decimal:const o=r;return{type:"decimal",bitWidth:o.bitWidth,precision:o.precision,scale:o.scale};case arrow3.Date_:return r.unit===arrow3.DateUnit.DAY?"date-day":"date-millisecond";case arrow3.DateDay:return"date-day";case arrow3.DateMillisecond:return"date-millisecond";case arrow3.Time:switch(r.unit){case arrow3.TimeUnit.SECOND:return"time-second";case arrow3.TimeUnit.MILLISECOND:return"time-millisecond";case arrow3.TimeUnit.MICROSECOND:return"time-microsecond";case arrow3.TimeUnit.NANOSECOND:return"time-nanosecond";default:return"time-second"}case arrow3.TimeMillisecond:return"time-millisecond";case arrow3.TimeSecond:return"time-second";case arrow3.TimeMicrosecond:return"time-microsecond";case arrow3.TimeNanosecond:return"time-nanosecond";case arrow3.Timestamp:switch(r.unit){case arrow3.TimeUnit.SECOND:return"timestamp-second";case arrow3.TimeUnit.MILLISECOND:return"timestamp-millisecond";case arrow3.TimeUnit.MICROSECOND:return"timestamp-microsecond";case arrow3.TimeUnit.NANOSECOND:return"timestamp-nanosecond";default:return"timestamp-second"}case arrow3.TimestampSecond:return"timestamp-second";case arrow3.TimestampMillisecond:return"timestamp-millisecond";case arrow3.TimestampMicrosecond:return"timestamp-microsecond";case arrow3.TimestampNanosecond:return"timestamp-nanosecond";case arrow3.Interval:switch(r.unit){case arrow3.IntervalUnit.DAY_TIME:return"interval-daytime";case arrow3.IntervalUnit.YEAR_MONTH:return"interval-yearmonth";default:return"interval-daytime"}case arrow3.IntervalDayTime:return"interval-daytime";case arrow3.IntervalYearMonth:return"interval-yearmonth";case arrow3.Map_:const t=r;return{type:"map",keysSorted:t.keysSorted,children:t.children.map((r=>serializeArrowField(r)))};case arrow3.List:return{type:"list",children:[serializeArrowField(r.valueField)]};case arrow3.FixedSizeList:const a=r;return{type:"fixed-size-list",listSize:a.listSize,children:[serializeArrowField(a.children[0])]};case arrow3.Struct:return{type:"struct",children:r.children.map((r=>serializeArrowField(r)))};default:throw new Error(`arrow type not supported: ${r.constructor.name}`)}}function deserializeArrowType(r){if("object"===typeof r)switch(r.type){case"decimal":return new arrow3.Decimal(r.precision,r.scale,r.bitWidth);case"map":let e=r.children.map((r=>deserializeArrowField(r)));return new arrow3.Map_(e,r.keysSorted);case"list":const o=deserializeArrowField(r.children[0]);return new arrow3.List(o);case"fixed-size-list":const t=deserializeArrowField(r.children[0]);return new arrow3.FixedSizeList(r.listSize,t);case"struct":return e=r.children.map((r=>deserializeArrowField(r))),new arrow3.Struct(e);default:throw new Error("array type not supported")}switch(r){case"null":return new arrow3.Null;case"binary":return new arrow3.Binary;case"bool":return new arrow3.Bool;case"int8":return new arrow3.Int8;case"int16":return new arrow3.Int16;case"int32":return new arrow3.Int32;case"int64":return new arrow3.Int64;case"uint8":return new arrow3.Uint8;case"uint16":return new arrow3.Uint16;case"uint32":return new arrow3.Uint32;case"uint64":return new arrow3.Uint64;case"float16":return new arrow3.Float16;case"float32":return new arrow3.Float32;case"float64":return new arrow3.Float64;case"utf8":return new arrow3.Utf8;case"date-day":return new arrow3.DateDay;case"date-millisecond":return new arrow3.DateMillisecond;case"time-second":return new arrow3.TimeSecond;case"time-millisecond":return new arrow3.TimeMillisecond;case"time-microsecond":return new arrow3.TimeMicrosecond;case"time-nanosecond":return new arrow3.TimeNanosecond;case"timestamp-second":return new arrow3.TimestampSecond;case"timestamp-millisecond":return new arrow3.TimestampMillisecond;case"timestamp-microsecond":return new arrow3.TimestampMicrosecond;case"timestamp-nanosecond":return new arrow3.TimestampNanosecond;case"interval-daytime":return new arrow3.IntervalDayTime;case"interval-yearmonth":return new arrow3.IntervalYearMonth;default:throw new Error("array type not supported")}}function parseArrowSync(r,e){const o=arrow4.tableFromIPC([new Uint8Array(r)]),t={shape:"arrow-table",schema:serializeArrowSchema(o.schema),data:o},a=(null==e?void 0:e.shape)||"arrow-table";switch(a){case"arrow-table":return t;case"columnar-table":return convertArrowToColumnarTable(t);case"object-row-table":let r=convertArrowToColumnarTable(t);return(0,import_schema2.convertTable)(r,"object-row-table");case"array-row-table":return r=convertArrowToColumnarTable(t),(0,import_schema2.convertTable)(r,"array-row-table");default:throw new Error(a)}}var arrow5=__toESM(require("apache-arrow"),1);function parseArrowInBatches(r,e){return async function*(){var o,t;const a=arrow5.RecordBatchReader.readAll(r);for await(const r of a){for await(const a of r){void 0!==(null==(o=null==e?void 0:e.arrow)?void 0:o.batchDebounceMs)&&(null==(t=null==e?void 0:e.arrow)?void 0:t.batchDebounceMs)>0&&await new Promise((r=>{var o;return setTimeout(r,(null==(o=e.arrow)?void 0:o.batchDebounceMs)||0)}));const r={shape:"arrow-table",batchType:"data",data:new arrow5.Table([a]),length:a.data.length};yield r}break}}()}var VERSION="undefined"!==typeof __VERSION__?__VERSION__:"latest",ArrowWorkerLoader={name:"Apache Arrow",id:"arrow",module:"arrow",version:VERSION,category:"table",extensions:["arrow","feather"],mimeTypes:["application/vnd.apache.arrow.file","application/vnd.apache.arrow.stream","application/octet-stream"],binary:!0,tests:["ARROW"],options:{arrow:{shape:"columnar-table"}}},ArrowLoader={...ArrowWorkerLoader,parse:async(r,e)=>parseArrowSync(r,null==e?void 0:e.arrow),parseSync:(r,e)=>parseArrowSync(r,null==e?void 0:e.arrow),parseInBatches:parseArrowInBatches},arrow6=__toESM(require("apache-arrow"),1);function encodeArrowSync(r){const e={};for(const t of r){const r=createVector(t.array,t.type);e[t.name]=r}const o=new arrow6.Table(e);return arrow6.tableToIPC(o)}function createVector(r,e){return arrow6.vectorFromArray(r)}var VERSION2="undefined"!==typeof __VERSION__?__VERSION__:"latest",ArrowWriter={name:"Apache Arrow",id:"arrow",module:"arrow",version:VERSION2,extensions:["arrow","feather"],mimeTypes:["application/vnd.apache.arrow.file","application/vnd.apache.arrow.stream","application/octet-stream"],binary:!0,options:{},encode:async function(r,e){return encodeArrowSync(r)},encodeSync:(r,e)=>encodeArrowSync(r)},import_arrow=require("@loaders.gl/arrow"),import_gis=require("@loaders.gl/gis");function convertArrowToGeoJSONTable(r){var e;const o=r.data,t=(0,import_arrow.serializeArrowSchema)(o.schema),a=(0,import_gis.getGeometryColumnsFromSchema)(t),n=a.geometry.encoding,i=[],s=o.schema.fields.map((r=>r.name)).filter((r=>!(r in a))),l=o.select(s),c=o.getChild("geometry");for(let u=0;u<o.numRows;u++){const r=null==c?void 0:c.get(u),o=(0,import_arrow.parseGeometryFromArrow)(r,n);if(o){const r=(null==(e=l.get(u))?void 0:e.toJSON())||{};i.push({type:"Feature",geometry:o,properties:r})}}return{shape:"geojson-table",type:"FeatureCollection",schema:r.schema,features:i}}function parseGeoArrowSync(r,e){const o=parseArrowSync(r,{shape:"arrow-table"});return"geojson-table"===(null==e?void 0:e.shape)?convertArrowToGeoJSONTable(o):o}function parseGeoArrowInBatches(r){return parseArrowInBatches(r)}var GeoArrowWorkerLoader={...ArrowWorkerLoader,options:{arrow:{shape:"arrow-table"}}},GeoArrowLoader={...ArrowWorkerLoader,options:{arrow:{shape:"arrow-table"}},parse:async(r,e)=>parseGeoArrowSync(r,null==e?void 0:e.arrow),parseSync:(r,e)=>parseGeoArrowSync(r,null==e?void 0:e.arrow),parseInBatches:parseGeoArrowInBatches},import_polygon=require("@math.gl/polygon");function updateBoundsFromGeoArrowSamples(r,e,o,t=100){const a=r.length/e,n=Math.max(Math.floor(a/t),1),i=[...o];for(let s=0;s<a;s+=n){const o=r[s*e],t=r[s*e+1];o<i[0]&&(i[0]=o),t<i[1]&&(i[1]=t),o>i[2]&&(i[2]=o),t>i[3]&&(i[3]=t)}return i}function getBinaryGeometryTemplate(){return{globalFeatureIds:{value:new Uint32Array(0),size:1},positions:{value:new Float32Array(0),size:2},properties:[],numericProps:{},featureIds:{value:new Uint32Array(0),size:1}}}function getBinaryGeometriesFromArrow(r,e,o){const t={polygon:"geoarrow.multipolygon"===e||"geoarrow.polygon"===e,point:"geoarrow.multipoint"===e||"geoarrow.point"===e,line:"geoarrow.multilinestring"===e||"geoarrow.linestring"===e},a=void 0!==(null==o?void 0:o.chunkIndex)&&(null==o?void 0:o.chunkIndex)>=0?[r.data[null==o?void 0:o.chunkIndex]]:r.data;let n=[1/0,1/0,-1/0,-1/0],i=(null==o?void 0:o.chunkOffset)||0;const s=[];return a.forEach((r=>{const{featureIds:a,flatCoordinateArray:l,nDim:c,geomOffset:u,triangles:w}=getBinaryGeometriesFromChunk(r,e,o),d=new Uint32Array(a.length);for(let e=0;e<a.length;e++)d[e]=a[e]+i;const m={globalFeatureIds:{value:d,size:1},positions:{value:l,size:c},featureIds:{value:a,size:1},properties:[...Array(r.length).keys()].map((r=>({index:r+i})))};i+=r.length,s.push({shape:"binary-feature-collection",points:{type:"Point",...getBinaryGeometryTemplate(),...t.point?m:{}},lines:{type:"LineString",...getBinaryGeometryTemplate(),...t.line?m:{},pathIndices:{value:t.line?u:new Uint16Array(0),size:1}},polygons:{type:"Polygon",...getBinaryGeometryTemplate(),...t.polygon?m:{},polygonIndices:{value:t.polygon?u:new Uint16Array(0),size:1},primitivePolygonIndices:{value:t.polygon?u:new Uint16Array(0),size:1},...w?{triangles:{value:w,size:1}}:{}}}),n=updateBoundsFromGeoArrowSamples(l,c,n)})),{binaryGeometries:s,bounds:n,featureTypes:t,...(null==o?void 0:o.calculateMeanCenters)?{meanCenters:getMeanCentersFromBinaryGeometries(s)}:{}}}function getMeanCentersFromBinaryGeometries(r){const e=[];return r.forEach((r=>{var o;let t=null;r.points&&r.points.positions.value.length>0?t="points":r.lines&&r.lines.positions.value.length>0?t="lines":r.polygons&&r.polygons.positions.value.length>0&&(t="polygons");const a=t?r[t]:null;if(a&&null!==t){getMeanCentersFromGeometry(a.featureIds.value,a.positions.value,a.positions.size,t,"Polygon"===a.type?null==(o=a.primitivePolygonIndices)?void 0:o.value:void 0).forEach((r=>{e.push(r)}))}})),e}function getMeanCentersFromGeometry(r,e,o,t,a){const n=[],i=e.length;let s=0,l=0,c=0;for(;s<i;){const u=r[s/o],w=[0,0];let d=0;for(;s<i&&r[l]===u;)"polygons"===t&&(null==a?void 0:a[c])===l?(s+=o,c++):(w[0]+=e[s],w[1]+=e[s+1],s+=o,d++),l+=1;w[0]/=d,w[1]/=d,n.push(w)}return n}function getBinaryGeometriesFromChunk(r,e,o){switch(e){case"geoarrow.point":case"geoarrow.multipoint":return getBinaryPointsFromChunk(r,e);case"geoarrow.linestring":case"geoarrow.multilinestring":return getBinaryLinesFromChunk(r,e);case"geoarrow.polygon":case"geoarrow.multipolygon":return getBinaryPolygonsFromChunk(r,e,o);default:throw Error("invalid geoarrow encoding")}}function getTriangleIndices(r,e,o,t){try{let a=0;const n=[];for(let s=0;s<r.length-1;s++){const i=r[s],l=r[s+1],c=o.subarray(i*t,l*t),u=[];for(;e[a]<l;)e[a]>i&&u.push(e[a]-i),a++;const w=(0,import_polygon.earcut)(c,u.length>0?u:void 0,t);if(0===w.length)throw Error("earcut failed e.g. invalid polygon");for(let r=0;r<w.length;r++)n.push(w[r]+i)}const i=new Uint32Array(n.length);for(let r=0;r<n.length;r++)i[r]=n[r];return i}catch(a){return null}}function getBinaryPolygonsFromChunk(r,e,o){const t="geoarrow.multipolygon"===e,a=t?r.children[0]:r,n=a.valueOffsets,i=t?r.valueOffsets.map((r=>n.at(r)||r)):r.valueOffsets,s=a.children[0],l=s.children[0],c=l.children[0],u=l.stride,w=s.valueOffsets,d=c.values,m=new Uint16Array(n.length);for(let g=0;g<n.length;g++)m[g]=w[n[g]];const p=d.length/u,f=new Uint32Array(p);for(let g=0;g<i.length-1;g++){const r=w[i[g]],e=w[i[g+1]];for(let o=r;o<e;o++)f[o]=g}const y=(null==o?void 0:o.triangulate)?getTriangleIndices(m,w,d,u):null;return{featureIds:f,nDim:u,flatCoordinateArray:d,geomOffset:w,geometryIndicies:m,...(null==o?void 0:o.triangulate)&&y?{triangles:y}:{}}}function getBinaryLinesFromChunk(r,e){const o="geoarrow.multilinestring"===e,t=o?r.children[0]:r,a=t.children[0],n=a.children[0],i=a.stride,s=t.valueOffsets,l=n.values,c=new Uint16Array(0),u=l.length/i,w=new Uint32Array(u);if(o){const e=r.valueOffsets;for(let r=0;r<e.length-1;r++){const o=s[e[r]],t=s[e[r+1]];for(let e=o;e<t;e++)w[e]=r}}else for(let d=0;d<r.length;d++){const r=s[d],e=s[d+1];for(let o=r;o<e;o++)w[o]=d}return{featureIds:w,flatCoordinateArray:l,nDim:i,geomOffset:s,geometryIndicies:c}}function getBinaryPointsFromChunk(r,e){const o="geoarrow.multipoint"===e,t=o?r.children[0]:r,a=t.children[0],n=t.stride,i=a.values,s=new Uint16Array(0),l=new Int32Array(0),c=i.length/n,u=new Uint32Array(c);if(o){const e=r.valueOffsets;for(let r=0;r<e.length-1;r++){const o=e[r],t=e[r+1];for(let e=o;e<t;e++)u[e]=r}}else for(let w=0;w<r.length;w++)u[w]=w;return{featureIds:u,flatCoordinateArray:i,nDim:n,geomOffset:l,geometryIndicies:s}}var import_gis2=require("@loaders.gl/gis"),import_wkt=require("@loaders.gl/wkt");function parseGeometryFromArrow2(r,e){if(!(e=null==e?void 0:e.toLowerCase())||!r)return null;let o;switch(e){case"geoarrow.multipolygon":o=arrowMultiPolygonToFeature(r);break;case"geoarrow.polygon":o=arrowPolygonToFeature(r);break;case"geoarrow.multipoint":o=arrowMultiPointToFeature(r);break;case"geoarrow.point":o=arrowPointToFeature(r);break;case"geoarrow.multilinestring":o=arrowMultiLineStringToFeature(r);break;case"geoarrow.linestring":o=arrowLineStringToFeature(r);break;case"geoarrow.wkb":o=arrowWKBToFeature(r);break;case"geoarrow.wkt":o=arrowWKTToFeature(r);break;default:throw Error(`GeoArrow encoding not supported ${e}`)}return o}function arrowWKBToFeature(r){var e,o;const t=r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength),a=null==(o=(e=import_wkt.WKBLoader).parseSync)?void 0:o.call(e,t);return(0,import_gis2.binaryToGeometry)(a)}function arrowWKTToFeature(r){var e,o;const t=r;return null==(o=(e=import_wkt.WKTLoader).parseTextSync)?void 0:o.call(e,t)}function arrowMultiPolygonToFeature(r){const e=[];for(let o=0;o<r.length;o++){const t=r.get(o),a=[];for(let r=0;t&&r<(null==t?void 0:t.length);r++){const e=null==t?void 0:t.get(r),o=[];for(let r=0;e&&r<e.length;r++){const t=e.get(r),a=Array.from(t);o.push(a)}a.push(o)}e.push(a)}return{type:"MultiPolygon",coordinates:e}}function arrowPolygonToFeature(r){const e=[];for(let o=0;r&&o<r.length;o++){const t=r.get(o),a=[];for(let r=0;t&&r<t.length;r++){const e=t.get(r),o=Array.from(e);a.push(o)}e.push(a)}return{type:"Polygon",coordinates:e}}function arrowMultiPointToFeature(r){const e=[];for(let o=0;r&&o<r.length;o++){const t=r.get(o);if(t){const r=Array.from(t);e.push(r)}}return{type:"MultiPoint",coordinates:e}}function arrowPointToFeature(r){return{type:"Point",coordinates:Array.from(r)}}function arrowMultiLineStringToFeature(r){const e=[];for(let o=0;r&&o<r.length;o++){const t=r.get(o),a=[];for(let r=0;t&&r<t.length;r++){const e=t.get(r);if(e){const r=Array.from(e);a.push(r)}}e.push(a)}return{type:"MultiLineString",coordinates:e}}function arrowLineStringToFeature(r){const e=[];for(let o=0;r&&o<r.length;o++){const t=r.get(o);if(t){const r=Array.from(t);e.push(r)}}return{type:"LineString",coordinates:e}}var arrow7=__toESM(require("apache-arrow"),1);function hardClone(r,e=!1){if("data"in r)return new arrow7.Vector(r.data.map((r=>hardClone(r,e))));const o=[];for(const n of r.children)o.push(hardClone(n,e));let t;void 0!==r.dictionary&&(t=hardClone(r.dictionary,e));const a={[arrow7.BufferType.OFFSET]:cloneBuffer(r.buffers[arrow7.BufferType.OFFSET],e),[arrow7.BufferType.DATA]:cloneBuffer(r.buffers[arrow7.BufferType.DATA],e),[arrow7.BufferType.VALIDITY]:cloneBuffer(r.buffers[arrow7.BufferType.VALIDITY],e),[arrow7.BufferType.TYPE]:cloneBuffer(r.buffers[arrow7.BufferType.TYPE],e)};return new arrow7.Data(r.type,r.offset,r.length,r._nullCount,a,o,t)}function isTypedArraySliced(r){return!(0===r.byteOffset&&r.byteLength===r.buffer.byteLength)}function cloneBuffer(r,e){return void 0===r?r:e||isTypedArraySliced(r)?r.slice():r}var import_worker_utils=require("@loaders.gl/worker-utils"),VERSION3="undefined"!==typeof __VERSION__?__VERSION__:"latest",TriangulationWorker={id:"triangulation",name:"Triangulate",module:"arrow",version:VERSION3,options:{}};function triangulateOnWorker(r,e={}){return(0,import_worker_utils.processOnWorker)(TriangulationWorker,{...r,operation:"triangulate"},e)}function parseGeoArrowOnWorker(r,e={}){return(0,import_worker_utils.processOnWorker)(TriangulationWorker,{...r,operation:"parse-geoarrow"},e)}import_schema3.TableBatchBuilder.ArrowBatch=ArrowTableBatchAggregator;